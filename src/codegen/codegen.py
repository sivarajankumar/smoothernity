from hashlib import md5
from os . path import dirname
from normalizer import normalizer
from normalizer import exception as normalizer_exception
from reader import reader
from reader import exception as reader_exception

def reify ( data , open_func , trace , options , os_mod ) :
    for raw_name , contents in sorted ( data . items ( ) ) :
        name = options . file_prefix ( ) + raw_name
        dir = dirname ( name )
        try :
            os_mod . makedirs ( dir )
            trace . dir_created ( dir )
        except :
            pass
        try :
            old_md5 = md5 ( open_func ( name , 'r' ) . read ( ) ) . hexdigest ( )
        except :
            old_md5 = None
        new_md5 = md5 ( contents ) . hexdigest ( )
        if new_md5 != old_md5 :
            try :
                open_func ( name , 'w' ) . write ( contents )
                if old_md5 is None :
                    trace . created ( name )
                else :
                    trace . overwritten ( name )
            except Exception as e :
                trace . write_error ( name , str ( e ) )

def generate ( input ) :
    res = { }
    res . update ( _generate_common_h ( ) )
    res . update ( _generate_common_hpp ( ) )
    res . update ( _generate_common_injections_h ( ) )
    res . update ( _generate_common_injections_cpp ( ) )
    res . update ( _generate_loadable_h ( ) )
    res . update ( _generate_loadable_hpp ( ) )
    res . update ( _generate_loadable_injections_h ( ) )
    res . update ( _generate_loadable_injections_cpp ( ) )
    return res

def _generate_common_h ( ) :
    return { 'autogenerated/common/shy_common.h' :
        'class shy_common\n'
        '{\n'
        'public :\n'
        '    static void init ( ) ;\n'
        '    static void done ( ) ;\n'
        '    static void next_frame ( ) ;\n'
        '} ;\n' }

def _generate_common_hpp ( ) :
    return { 'autogenerated/common/shy_common.hpp' :
        'void shy_common :: init ( )\n'
        '{\n'
        '}\n'
        '\n'
        'void shy_common :: done ( )\n'
        '{\n'
        '}\n'
        '\n'
        'void shy_common :: next_frame ( )\n'
        '{\n'
        '}\n' }

def _generate_common_injections_h ( ) :
    return { 'autogenerated/common/shy_common_injections.h' :
        '#ifndef _shy_common_injections_included\n'
        '#define _shy_common_injections_included\n'
        '\n'
        '#include "autogenerated/common/shy_common.h"\n'
        'typedef shy_common so_called_common ;\n'
        '\n'
        '#endif\n' }

def _generate_common_injections_cpp ( ) :
    return { 'autogenerated/common/shy_common_injections.cpp' :
        '#include "autogenerated/common/shy_common_injections.h"\n'
        '#include "autogenerated/common/shy_common.hpp"\n' }

def _generate_loadable_h ( ) :
    return { 'autogenerated/loadable/shy_loadable.h' :
        'class shy_loadable\n'
        '{\n'
        'public :\n'
        '    static void load ( ) ;\n'
        '} ;\n' }

def _generate_loadable_hpp ( ) :
    return { 'autogenerated/loadable/shy_loadable.hpp' :
        'void shy_loadable :: load ( )\n'
        '{\n'
        '}\n' }

def _generate_loadable_injections_h ( ) :
    return { 'autogenerated/loadable/shy_loadable_injections.h' :
        '#ifndef _shy_loadable_injections_included\n'
        '#define _shy_loadable_injections_included\n'
        '\n'
        '#include "autogenerated/loadable/shy_loadable.h"\n'
        'typedef shy_loadable so_called_loadable ;\n'
        '\n'
        '#endif\n' }

def _generate_loadable_injections_cpp ( ) :
    return { 'autogenerated/loadable/shy_loadable_injections.cpp' :
        '#include "autogenerated/loadable/shy_loadable_injections.h"\n'
        '#include "autogenerated/loadable/shy_loadable.hpp"\n' }

if __name__ == '__main__' :
    from sys import argv
    from sys import stdin
    import os
    from pprint import pprint

    class trace :
        def write_error ( self , name , error ) :
            print 'Cannot write file "' + name + '": %s' % error
        def created ( self , name ) :
            print 'File "' + name + '" has been created.'
        def overwritten ( self , name ) :
            print 'File "' + name + '" has been overwritten.'
        def dir_created ( self , name ) :
            print 'Path "' + name + '" has been created.'

    class options :
        def file_prefix ( self ) :
            return argv [ 1 ]
        
    try :
        n = normalizer ( )
        bf = n . bind_func
        bf ( 'platform_conditions_fract_greater_than_fract' , [ { } ] * 2 )
        bf ( 'platform_conditions_fract_less_than_fract' , [ { } ] * 2 )
        bf ( 'platform_conditions_whole_greater_than_whole' , [ { } ] * 2 )
        bf ( 'platform_conditions_whole_less_than_whole' , [ { } ] * 2 )
        bf ( 'platform_conditions_whole_less_than_zero' , [ { } ] * 1 )
        bf ( 'platform_math_add_fracts' , [ { } ] * 3 )
        bf ( 'platform_math_add_to_fract' , [ { } ] * 2 )
        bf ( 'platform_math_cos' , [ { } ] * 2 )
        bf ( 'platform_math_mul_fracts' , [ { } ] * 3 )
        bf ( 'platform_math_neg_whole' , [ { } ] * 2 )
        bf ( 'platform_math_sin' , [ { } ] * 2 )
        bf ( 'platform_math_sub_fracts' , [ { } ] * 3 )
        bf ( 'platform_math_sub_from_fract' , [ { } ] * 2 )
        bf ( 'platform_vector_mul_by' , [ { } ] * 2 )
        bf ( 'platform_vector_xyz' , [ { } ] * 4 )
        pprint ( n . run ( reader ( ) . run ( stdin ) ) )
    except reader_exception as e :
        pprint ( e . get_src ( ) )
        print 'reader exception:' , str ( e )
    except normalizer_exception as e :
        pprint ( e . get_src ( ) )
        print 'normalizer exception:' , str ( e )
        print 'at'
        pprint ( e . get_path ( ) )
    reify ( generate ( [ ] ) , open , trace ( ) , options ( ) , os )
