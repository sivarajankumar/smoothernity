template < typename _data_content >
class shy_data_generator_types
{
public :
    typedef _data_content data_content ;
} ;

template < typename data_generator_types >
class shy_data_generator
{
    typedef typename data_generator_types :: data_content data_content ;
    typedef typename data_generator_types :: data_content :: data_content_fract data_content_fract ;
    typedef typename data_generator_types :: data_content :: data_content_fract_container data_content_fract_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_machine data_content_fsm_machine ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_machine_container data_content_fsm_machine_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_state_container data_content_fsm_state_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_system data_content_fsm_system ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_system_container data_content_fsm_system_container ;
    typedef typename data_generator_types :: data_content :: data_content_module data_content_module ;
    typedef typename data_generator_types :: data_content :: data_content_module_container data_content_module_container ;
    typedef typename data_generator_types :: data_content :: data_content_whole data_content_whole ;
    typedef typename data_generator_types :: data_content :: data_content_whole_container data_content_whole_container ;

    class _consts
    {
    public :
        static std :: string file_begin ( )
        {
            return std :: string ( "// autogenerated file begin\n" ) ;
        }
        static std :: string file_end ( )
        {
            return std :: string ( "\n// autogenerated file end\n" ) ;
        }
        static std :: string fsm_inputs_type_begin ( )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "    class _autogenerated_inputs_type\n" )
                + std :: string ( "    {\n" ) 
                ;
        }
        static std :: string fsm_inputs_type_end ( )
        {
            return std :: string ( "    } ;\n" ) ;
        }
        static std :: string fsm_system_begin ( std :: string name )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " ) + name + std :: string ( "_fsm >\n" )
                + std :: string ( "class shy_" ) + name + std :: string ( "_fsm_autogenerated\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    class _state_environment_type ;\n" )
                + std :: string ( "    class _states_type ;\n" )
                + std :: string ( "\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: engine_fsm engine_fsm ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_conditions platform_conditions ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_math platform_math ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_math :: num_whole num_whole ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_pointer platform_pointer ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: actions_type actions_type ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: inputs_type inputs_type ;\n" )
                + std :: string ( "    typedef typename engine_fsm :: template fsm_state_type < _state_environment_type > _state_type ;\n" )
                + std :: string ( "    typedef shy_" ) + name + std :: string ( "_fsm_autogenerated < " ) + name + std :: string ( "_fsm > " ) + name + std :: string ( "_fsm_autogenerated ;\n" ) ;
                ;
        }
        static std :: string fsm_system_end ( )
        {
            return std :: string ( "} ;\n" ) ;
        }
        static std :: string module_begin ( std :: string name )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename mediator >\n" )
                + std :: string ( "shy_" ) + name + std :: string ( " < mediator >\n" )
                + std :: string ( ":: " ) + name + std :: string ( "_consts_type \n" )
                + std :: string ( ":: " ) + name + std :: string ( "_consts_type ( )\n" )
                + std :: string ( "{\n" )
                ;
        } ;
        static std :: string module_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string set_fract_value ( std :: string name , std :: string numerator , std :: string denominator )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_fract ( " ) 
                + name 
                + std :: string ( " , " )
                + numerator
                + std :: string ( " , " )
                + denominator
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string set_whole_value ( std :: string name , std :: string value )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_whole ( " )
                + name
                + std :: string ( " , " )
                + value
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string whitespace ( )
        {
            return std :: string ( " " ) ;
        }
    } ;

public :
    shy_data_generator ( ) ;
    void set_content ( const data_content & ) ;
    std :: string generate ( ) ;
private :
    void _generate_modules ( ) ;
    void _generate_fsm_systems ( ) ;
    void _generate_fsm_inputs_type ( ) ;
private :
    const data_content * _content ;
    const data_content_fsm_system * _current_fsm_system ;
    std :: string _modules_code ;
    std :: string _fsm_systems_code ;
    std :: string _fsm_inputs_type_code ;
} ;

template < typename data_generator_types >
shy_data_generator < data_generator_types > :: shy_data_generator ( )
: _content ( 0 )
, _current_fsm_system ( 0 )
{
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: set_content ( const data_content & content )
{
    _content = & content ;
}

template < typename data_generator_types >
std :: string shy_data_generator < data_generator_types > :: generate ( )
{
    _generate_modules ( ) ;
    _generate_fsm_systems ( ) ;

    return _consts :: file_begin ( )
         + _modules_code
         + _fsm_systems_code
         + _consts :: file_end ( )
         ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_modules ( )
{
    for ( typename data_content :: data_content_module_container :: const_iterator module_i = _content -> modules . begin ( )
        ; module_i != _content -> modules . end ( )
        ; ++ module_i
        )
    {
        std :: string module_name = module_i -> first ;
        const data_content_module & module = module_i -> second ;

        _modules_code += _consts :: module_begin ( module_name ) ;

        for ( typename data_content_whole_container :: const_iterator whole_i = module . name_to_whole . begin ( )
            ; whole_i != module . name_to_whole . end ( )
            ; ++ whole_i
            )
        {
            std :: string whole_name = whole_i -> first ;
            const data_content_whole & whole = whole_i -> second ;
            
            std :: string value ;
            value += whole . sign ;
            if ( ! value . empty ( ) )
                value += _consts :: whitespace ( ) ;
            value += whole . value ;

            _modules_code += _consts :: set_whole_value ( whole_name , value ) ;
        }
        for ( typename data_content_fract_container :: const_iterator fract_i = module . name_to_fract . begin ( )
            ; fract_i != module . name_to_fract . end ( )
            ; ++ fract_i
            )
        {
            std :: string fract_name = fract_i -> first ;
            const data_content_fract & fract = fract_i -> second ;
            
            std :: string numerator ;
            numerator += fract . numerator_sign ;
            if ( ! numerator . empty ( ) )
                numerator += _consts :: whitespace ( ) ;
            numerator += fract . numerator_value ;

            std :: string denominator ;
            denominator += fract . denominator_sign ;
            if ( ! denominator . empty ( ) )
                denominator += _consts :: whitespace ( ) ;
            denominator += fract . denominator_value ;

            _modules_code += _consts :: set_fract_value ( fract_name , numerator , denominator ) ;
        }
        _modules_code += _consts :: module_end ( ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_systems ( )
{
    for ( typename data_content_fsm_system_container :: const_iterator fsm_system_i = _content -> fsm_systems . begin ( )
        ; fsm_system_i != _content -> fsm_systems . end ( )
        ; ++ fsm_system_i
        )
    {
        std :: string fsm_system_name = fsm_system_i -> first ;
        const data_content_fsm_system & fsm_system = fsm_system_i -> second ;

        _current_fsm_system = & fsm_system ;
        _generate_fsm_inputs_type ( ) ;

        _fsm_systems_code = _fsm_systems_code
            + _consts :: fsm_system_begin ( fsm_system_name )
            + _fsm_inputs_type_code
            + _consts :: fsm_system_end ( )
            ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_inputs_type ( )
{
    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;
        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
        }
    }

    _fsm_inputs_type_code
        = _consts :: fsm_inputs_type_begin ( )
        + _consts :: fsm_inputs_type_end ( ) ;
}

