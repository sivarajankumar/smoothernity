template < typename _data_modules >
class shy_data_generator_types
{
public :
    typedef _data_modules data_modules ;
} ;

template < typename data_generator_types >
class shy_data_generator
{
    typedef typename data_generator_types :: data_modules data_modules ;
    typedef typename data_generator_types :: data_modules :: data_modules_attributes data_modules_attributes ;
    typedef typename data_generator_types :: data_modules :: data_modules_fract data_modules_fract ;
    typedef typename data_generator_types :: data_modules :: data_modules_whole data_modules_whole ;

    class _consts
    {
    public :
        static std :: string file_begin ( )
        {
            return std :: string ( "// autogenerated file begin\n" ) ;
        }
        static std :: string file_end ( )
        {
            return std :: string ( "\n// autogenerated file end\n" ) ;
        }
        static std :: string module_begin ( std :: string name )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename mediator >\n" )
                + std :: string ( "shy_" ) + name + std :: string ( " < mediator >\n" )
                + std :: string ( ":: " ) + name + std :: string ( "_consts_type \n" )
                + std :: string ( ":: " ) + name + std :: string ( "_consts_type ( )\n" )
                + std :: string ( "{\n" )
                ;
        } ;
        static std :: string module_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string set_fract_value ( std :: string name , std :: string numerator , std :: string denominator )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_fract ( " ) 
                + name 
                + std :: string ( " , " )
                + numerator
                + std :: string ( " , " )
                + denominator
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string set_whole_value ( std :: string name , std :: string value )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_whole ( " )
                + name
                + std :: string ( " , " )
                + value
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string whitespace ( )
        {
            return std :: string ( " " ) ;
        }
    } ;

public :
    shy_data_generator ( ) ;
    void set_modules ( data_modules & ) ;
    std :: string generate ( ) ;
private :
    data_modules * _modules ;
} ;

template < typename data_generator_types >
shy_data_generator < data_generator_types > :: shy_data_generator ( )
: _modules ( 0 )
{
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: set_modules ( data_modules & modules )
{
    _modules = & modules ;
}

template < typename data_generator_types >
std :: string shy_data_generator < data_generator_types > :: generate ( )
{
    std :: string code ;

    code += _consts :: file_begin ( ) ;

    for ( typename data_modules :: name_to_module_type :: const_iterator module_i = _modules -> modules . begin ( )
        ; module_i != _modules -> modules . end ( )
        ; ++ module_i
        )
    {
        std :: string module_name = module_i -> first ;
        const data_modules_attributes & attributes = module_i -> second ;

        code += _consts :: module_begin ( module_name ) ;

        for ( typename data_modules :: name_to_whole_type :: const_iterator attribute_i = attributes . name_to_whole . begin ( )
            ; attribute_i != attributes . name_to_whole . end ( )
            ; ++ attribute_i
            )
        {
            std :: string whole_name = attribute_i -> first ;
            const data_modules_whole & whole = attribute_i -> second ;
            
            std :: string value ;
            value += whole . sign ;
            if ( ! value . empty ( ) )
                value += _consts :: whitespace ( ) ;
            value += whole . value ;

            code += _consts :: set_whole_value ( whole_name , value ) ;
        }
        for ( typename data_modules :: name_to_fract_type :: const_iterator attribute_i = attributes . name_to_fract . begin ( )
            ; attribute_i != attributes . name_to_fract . end ( )
            ; ++ attribute_i
            )
        {
            std :: string fract_name = attribute_i -> first ;
            const data_modules_fract & fract = attribute_i -> second ;
            
            std :: string numerator ;
            numerator += fract . numerator_sign ;
            if ( ! numerator . empty ( ) )
                numerator += _consts :: whitespace ( ) ;
            numerator += fract . numerator_value ;

            std :: string denominator ;
            denominator += fract . denominator_sign ;
            if ( ! denominator . empty ( ) )
                denominator += _consts :: whitespace ( ) ;
            denominator += fract . denominator_value ;

            code += _consts :: set_fract_value ( fract_name , numerator , denominator ) ;
        }
        code += _consts :: module_end ( ) ;
    }

    code += _consts :: file_end ( ) ;

    return code ;
}

