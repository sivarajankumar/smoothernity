template < typename _data_content >
class shy_data_generator_types
{
public :
    typedef _data_content data_content ;
} ;

template < typename data_generator_types >
class shy_data_generator
{
    typedef typename data_generator_types :: data_content data_content ;
    typedef typename data_generator_types :: data_content :: data_content_fract data_content_fract ;
    typedef typename data_generator_types :: data_content :: data_content_fract_container data_content_fract_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_action_command data_content_fsm_action_command ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_action_command_container data_content_fsm_action_command_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_actions data_content_fsm_actions ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_command data_content_fsm_condition_command ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_command_container data_content_fsm_condition_command_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_group data_content_fsm_condition_group ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_group_container data_content_fsm_condition_group_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_state data_content_fsm_condition_state ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_state_container data_content_fsm_condition_state_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_on_input data_content_fsm_on_input ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_on_input_container data_content_fsm_on_input_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_machine data_content_fsm_machine ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_machine_container data_content_fsm_machine_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_state data_content_fsm_state ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_state_container data_content_fsm_state_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_system data_content_fsm_system ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_system_container data_content_fsm_system_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_transition data_content_fsm_transition ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_transition_container data_content_fsm_transition_container ;
    typedef typename data_generator_types :: data_content :: data_content_module data_content_module ;
    typedef typename data_generator_types :: data_content :: data_content_module_container data_content_module_container ;
    typedef typename data_generator_types :: data_content :: data_content_whole data_content_whole ;
    typedef typename data_generator_types :: data_content :: data_content_whole_container data_content_whole_container ;

    typedef std :: set < std :: string > _collected_fsm_inputs_type ;

    class _consts
    {
    public :
        static std :: string file_begin ( )
        {
            return std :: string ( "// autogenerated file begin\n" ) ;
        }
        static std :: string file_end ( )
        {
            return std :: string ( "\n// autogenerated file end\n" ) ;
        }
        static std :: string fsm_input_command ( std :: string machine , std :: string command )
        {
            return std :: string ( "machine_" ) + machine + std :: string ( "_command_" ) + command ;
        }
        static std :: string fsm_input_state ( std :: string machine , std :: string state )
        {
            return std :: string ( "machine_" ) + machine + std :: string ( "_state_" ) + state ;
        }
        static std :: string fsm_inputs_type_begin ( )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "    class _autogenerated_inputs_type\n" )
                + std :: string ( "    {\n" ) 
                + std :: string ( "    public :\n" ) 
                ;
        }
        static std :: string fsm_inputs_type_end ( )
        {
            return std :: string ( "    } ;\n" ) ;
        }
        static std :: string fsm_inputs_type_entry ( std :: string input )
        {
            return std :: string ( "        num_whole " ) + input + std :: string ( " ;\n" ) ;
        }
        static std :: string fsm_system_begin ( std :: string name )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " ) + name + std :: string ( "_fsm >\n" )
                + std :: string ( "class shy_" ) + name + std :: string ( "_fsm_autogenerated\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    class _state_environment_type ;\n" )
                + std :: string ( "    class _states_type ;\n" )
                + std :: string ( "\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: engine_fsm engine_fsm ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_conditions platform_conditions ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_math platform_math ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_math :: num_whole num_whole ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_pointer platform_pointer ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: actions_type actions_type ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: inputs_type inputs_type ;\n" )
                + std :: string ( "    typedef typename engine_fsm :: template fsm_state_type < _state_environment_type > _state_type ;\n" )
                + std :: string ( "    typedef shy_" ) + name + std :: string ( "_fsm_autogenerated < " ) + name + std :: string ( "_fsm > " ) + name + std :: string ( "_fsm_autogenerated ;\n" ) ;
                ;
        }
        static std :: string fsm_system_end ( )
        {
            return std :: string ( "} ;\n" ) ;
        }
        static std :: string module_begin ( std :: string name )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename mediator >\n" )
                + std :: string ( "shy_" ) + name + std :: string ( " < mediator >\n" )
                + std :: string ( ":: " ) + name + std :: string ( "_consts_type \n" )
                + std :: string ( ":: " ) + name + std :: string ( "_consts_type ( )\n" )
                + std :: string ( "{\n" )
                ;
        } ;
        static std :: string module_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string set_fract_value ( std :: string name , std :: string numerator , std :: string denominator )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_fract ( " ) 
                + name 
                + std :: string ( " , " )
                + numerator
                + std :: string ( " , " )
                + denominator
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string set_whole_value ( std :: string name , std :: string value )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_whole ( " )
                + name
                + std :: string ( " , " )
                + value
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string whitespace ( )
        {
            return std :: string ( " " ) ;
        }
    } ;

public :
    shy_data_generator ( ) ;
    void set_content ( const data_content & ) ;
    std :: string generate ( ) ;
private :
    void _generate_modules ( ) ;
    void _generate_fsm_systems ( ) ;
    void _generate_fsm_inputs_type ( ) ;
    void _collect_fsm_inputs_from_actions ( const data_content_fsm_actions & ) ;
    void _collect_fsm_inputs_from_condition_groups ( std :: string , const data_content_fsm_condition_group_container & ) ;
private :
    const data_content * _content ;
    const data_content_fsm_system * _current_fsm_system ;
    std :: string _modules_code ;
    std :: string _fsm_systems_code ;
    std :: string _fsm_inputs_type_code ;
    _collected_fsm_inputs_type _collected_fsm_inputs ;
} ;

template < typename data_generator_types >
shy_data_generator < data_generator_types > :: shy_data_generator ( )
: _content ( 0 )
, _current_fsm_system ( 0 )
{
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: set_content ( const data_content & content )
{
    _content = & content ;
}

template < typename data_generator_types >
std :: string shy_data_generator < data_generator_types > :: generate ( )
{
    _generate_modules ( ) ;
    _generate_fsm_systems ( ) ;

    return _consts :: file_begin ( )
         + _modules_code
         + _fsm_systems_code
         + _consts :: file_end ( )
         ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_modules ( )
{
    for ( typename data_content :: data_content_module_container :: const_iterator module_i = _content -> modules . begin ( )
        ; module_i != _content -> modules . end ( )
        ; ++ module_i
        )
    {
        std :: string module_name = module_i -> first ;
        const data_content_module & module = module_i -> second ;

        _modules_code += _consts :: module_begin ( module_name ) ;

        for ( typename data_content_whole_container :: const_iterator whole_i = module . name_to_whole . begin ( )
            ; whole_i != module . name_to_whole . end ( )
            ; ++ whole_i
            )
        {
            std :: string whole_name = whole_i -> first ;
            const data_content_whole & whole = whole_i -> second ;
            
            std :: string value ;
            value += whole . sign ;
            if ( ! value . empty ( ) )
                value += _consts :: whitespace ( ) ;
            value += whole . value ;

            _modules_code += _consts :: set_whole_value ( whole_name , value ) ;
        }
        for ( typename data_content_fract_container :: const_iterator fract_i = module . name_to_fract . begin ( )
            ; fract_i != module . name_to_fract . end ( )
            ; ++ fract_i
            )
        {
            std :: string fract_name = fract_i -> first ;
            const data_content_fract & fract = fract_i -> second ;
            
            std :: string numerator ;
            numerator += fract . numerator_sign ;
            if ( ! numerator . empty ( ) )
                numerator += _consts :: whitespace ( ) ;
            numerator += fract . numerator_value ;

            std :: string denominator ;
            denominator += fract . denominator_sign ;
            if ( ! denominator . empty ( ) )
                denominator += _consts :: whitespace ( ) ;
            denominator += fract . denominator_value ;

            _modules_code += _consts :: set_fract_value ( fract_name , numerator , denominator ) ;
        }
        _modules_code += _consts :: module_end ( ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_systems ( )
{
    for ( typename data_content_fsm_system_container :: const_iterator fsm_system_i = _content -> fsm_systems . begin ( )
        ; fsm_system_i != _content -> fsm_systems . end ( )
        ; ++ fsm_system_i
        )
    {
        std :: string fsm_system_name = fsm_system_i -> first ;
        const data_content_fsm_system & fsm_system = fsm_system_i -> second ;

        _current_fsm_system = & fsm_system ;
        _generate_fsm_inputs_type ( ) ;

        _fsm_systems_code = _fsm_systems_code
            + _consts :: fsm_system_begin ( fsm_system_name )
            + _fsm_inputs_type_code
            + _consts :: fsm_system_end ( )
            ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_inputs_type ( )
{
    _collected_fsm_inputs . clear ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        std :: string fsm_machine_name = fsm_machine_i -> first ;
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;
        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
            const data_content_fsm_state & fsm_state = fsm_state_i -> second ;
            _collect_fsm_inputs_from_actions ( fsm_state . on_entry ) ;
            _collect_fsm_inputs_from_actions ( fsm_state . on_exit ) ;
            for ( typename data_content_fsm_on_input_container :: const_iterator fsm_on_input_i = fsm_state . on_input . begin ( )
                ; fsm_on_input_i != fsm_state . on_input . end ( )
                ; ++ fsm_on_input_i
                )
            {
                const data_content_fsm_on_input & fsm_on_input = * fsm_on_input_i ;
                _collect_fsm_inputs_from_condition_groups ( fsm_machine_name , fsm_on_input . condition_groups ) ;
                _collect_fsm_inputs_from_actions ( fsm_on_input . actions ) ;
            }
            for ( typename data_content_fsm_transition_container :: const_iterator fsm_transition_i = fsm_state . transitions . begin ( )
                ; fsm_transition_i != fsm_state . transitions . end ( )
                ; ++ fsm_transition_i
                )
            {
                const data_content_fsm_transition & fsm_transition = * fsm_transition_i ;
                _collect_fsm_inputs_from_condition_groups ( fsm_machine_name , fsm_transition . condition_groups ) ;
            }
        }
    }

    _fsm_inputs_type_code = _consts :: fsm_inputs_type_begin ( ) ;

    for ( typename _collected_fsm_inputs_type :: const_iterator collected_input_i = _collected_fsm_inputs . begin ( )
        ; collected_input_i != _collected_fsm_inputs . end ( )
        ; ++ collected_input_i
        )
    {
        _fsm_inputs_type_code += _consts :: fsm_inputs_type_entry ( * collected_input_i ) ;
    }

    _fsm_inputs_type_code += _consts :: fsm_inputs_type_end ( ) ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _collect_fsm_inputs_from_actions ( const data_content_fsm_actions & actions )
{
    for ( typename data_content_fsm_action_command_container :: const_iterator command_i = actions . commands . begin ( )
        ; command_i != actions . commands . end ( )
        ; ++ command_i
        )
    {
        const data_content_fsm_action_command & command = * command_i ;
        _collected_fsm_inputs . insert ( _consts :: fsm_input_command ( command . machine , command . command ) ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _collect_fsm_inputs_from_condition_groups 
    ( std :: string fsm_machine_name
    , const data_content_fsm_condition_group_container & condition_groups
    )
{
    for ( typename data_content_fsm_condition_group_container :: const_iterator condition_group_i = condition_groups . begin ( )
        ; condition_group_i != condition_groups . end ( )
        ; ++ condition_group_i
        )
    {
        const data_content_fsm_condition_group & condition_group = * condition_group_i ;
        for ( typename data_content_fsm_condition_state_container :: const_iterator condition_state_i = condition_group . states . begin ( )
            ; condition_state_i != condition_group . states . end ( )
            ; ++ condition_state_i
            )
        {
            const data_content_fsm_condition_state & condition_state = * condition_state_i ;
            _collected_fsm_inputs . insert ( _consts :: fsm_input_state ( condition_state . machine , condition_state . state ) ) ;
        }
        for ( typename data_content_fsm_condition_command_container :: const_iterator condition_command_i = condition_group . commands . begin ( )
            ; condition_command_i != condition_group . commands . end ( )
            ; ++ condition_command_i
            )
        {
            const data_content_fsm_condition_command & condition_command = * condition_command_i ;
            _collected_fsm_inputs . insert ( _consts :: fsm_input_command ( fsm_machine_name , condition_command . command ) ) ;
        }
    }
}

