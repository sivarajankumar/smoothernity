template < typename _data_content >
class shy_data_generator_types
{
public :
    typedef _data_content data_content ;
} ;

template < typename data_generator_types >
class shy_data_generator
{
    typedef typename data_generator_types :: data_content data_content ;
    typedef typename data_generator_types :: data_content :: data_content_attributes data_content_attributes ;
    typedef typename data_generator_types :: data_content :: data_content_attributes_container data_content_attributes_container ;
    typedef typename data_generator_types :: data_content :: data_content_fract data_content_fract ;
    typedef typename data_generator_types :: data_content :: data_content_fract_container data_content_fract_container ;
    typedef typename data_generator_types :: data_content :: data_content_whole data_content_whole ;
    typedef typename data_generator_types :: data_content :: data_content_whole_container data_content_whole_container ;

    class _consts
    {
    public :
        static std :: string file_begin ( )
        {
            return std :: string ( "// autogenerated file begin\n" ) ;
        }
        static std :: string file_end ( )
        {
            return std :: string ( "\n// autogenerated file end\n" ) ;
        }
        static std :: string module_begin ( std :: string name )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename mediator >\n" )
                + std :: string ( "shy_" ) + name + std :: string ( " < mediator >\n" )
                + std :: string ( ":: " ) + name + std :: string ( "_consts_type \n" )
                + std :: string ( ":: " ) + name + std :: string ( "_consts_type ( )\n" )
                + std :: string ( "{\n" )
                ;
        } ;
        static std :: string module_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string set_fract_value ( std :: string name , std :: string numerator , std :: string denominator )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_fract ( " ) 
                + name 
                + std :: string ( " , " )
                + numerator
                + std :: string ( " , " )
                + denominator
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string set_whole_value ( std :: string name , std :: string value )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_whole ( " )
                + name
                + std :: string ( " , " )
                + value
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string whitespace ( )
        {
            return std :: string ( " " ) ;
        }
    } ;

public :
    shy_data_generator ( ) ;
    void set_content ( data_content & ) ;
    std :: string generate ( ) ;
private :
    data_content * _content ;
} ;

template < typename data_generator_types >
shy_data_generator < data_generator_types > :: shy_data_generator ( )
: _content ( 0 )
{
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: set_content ( data_content & content )
{
    _content = & content ;
}

template < typename data_generator_types >
std :: string shy_data_generator < data_generator_types > :: generate ( )
{
    std :: string code ;

    code += _consts :: file_begin ( ) ;

    for ( typename data_content :: data_content_attributes_container :: const_iterator module_i = _content -> modules . begin ( )
        ; module_i != _content -> modules . end ( )
        ; ++ module_i
        )
    {
        std :: string module_name = module_i -> first ;
        const data_content_attributes & attributes = module_i -> second ;

        code += _consts :: module_begin ( module_name ) ;

        for ( typename data_content_whole_container :: const_iterator attribute_i = attributes . name_to_whole . begin ( )
            ; attribute_i != attributes . name_to_whole . end ( )
            ; ++ attribute_i
            )
        {
            std :: string whole_name = attribute_i -> first ;
            const data_content_whole & whole = attribute_i -> second ;
            
            std :: string value ;
            value += whole . sign ;
            if ( ! value . empty ( ) )
                value += _consts :: whitespace ( ) ;
            value += whole . value ;

            code += _consts :: set_whole_value ( whole_name , value ) ;
        }
        for ( typename data_content_fract_container :: const_iterator attribute_i = attributes . name_to_fract . begin ( )
            ; attribute_i != attributes . name_to_fract . end ( )
            ; ++ attribute_i
            )
        {
            std :: string fract_name = attribute_i -> first ;
            const data_content_fract & fract = attribute_i -> second ;
            
            std :: string numerator ;
            numerator += fract . numerator_sign ;
            if ( ! numerator . empty ( ) )
                numerator += _consts :: whitespace ( ) ;
            numerator += fract . numerator_value ;

            std :: string denominator ;
            denominator += fract . denominator_sign ;
            if ( ! denominator . empty ( ) )
                denominator += _consts :: whitespace ( ) ;
            denominator += fract . denominator_value ;

            code += _consts :: set_fract_value ( fract_name , numerator , denominator ) ;
        }
        code += _consts :: module_end ( ) ;
    }

    code += _consts :: file_end ( ) ;

    return code ;
}

