template < typename _data_content >
class shy_data_generator_types
{
public :
    typedef _data_content data_content ;
} ;

template < typename data_generator_types >
class shy_data_generator
{
    typedef typename data_generator_types :: data_content data_content ;
    typedef typename data_generator_types :: data_content :: data_content_fract data_content_fract ;
    typedef typename data_generator_types :: data_content :: data_content_fract_container data_content_fract_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_action_command data_content_fsm_action_command ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_action_command_container data_content_fsm_action_command_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_action_do data_content_fsm_action_do ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_action_do_container data_content_fsm_action_do_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_actions data_content_fsm_actions ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_command data_content_fsm_condition_command ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_command_container data_content_fsm_condition_command_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_group data_content_fsm_condition_group ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_group_container data_content_fsm_condition_group_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_input data_content_fsm_condition_input ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_input_container data_content_fsm_condition_input_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_state data_content_fsm_condition_state ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_condition_state_container data_content_fsm_condition_state_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_on_input data_content_fsm_on_input ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_on_input_container data_content_fsm_on_input_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_machine data_content_fsm_machine ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_machine_container data_content_fsm_machine_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_state data_content_fsm_state ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_state_container data_content_fsm_state_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_system data_content_fsm_system ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_system_container data_content_fsm_system_container ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_transition data_content_fsm_transition ;
    typedef typename data_generator_types :: data_content :: data_content_fsm_transition_container data_content_fsm_transition_container ;
    typedef typename data_generator_types :: data_content :: data_content_module data_content_module ;
    typedef typename data_generator_types :: data_content :: data_content_module_container data_content_module_container ;
    typedef typename data_generator_types :: data_content :: data_content_whole data_content_whole ;
    typedef typename data_generator_types :: data_content :: data_content_whole_container data_content_whole_container ;

    typedef std :: set < std :: string > _collected_fsm_actions_type ;
    typedef std :: set < std :: string > _collected_fsm_inputs_type ;
    typedef std :: set < std :: string > _collected_fsm_recalc_inputs_entries_type ;

    class _consts
    {
    public :
        static std :: string file_begin ( )
        {
            return std :: string ( "// autogenerated file begin\n" ) ;
        }
        static std :: string file_end ( )
        {
            return std :: string ( "\n// autogenerated file end\n" ) ;
        }
        static std :: string fsm_action_command_implementation ( std :: string machine , std :: string command )
        {
            return std :: string ( )
                + std :: string ( "    env . autogenerated_actions . get ( ) . " )
                + machine
                + std :: string ( "_command_" )
                + command
                + std :: string ( " ( ) ;\n" )
                ;
        }
        static std :: string fsm_action_do_implementation ( std :: string action )
        {
            return std :: string ( "    env . actions . get ( ) . " ) + action + std :: string ( " ( ) ;\n" ) ;
        }
        static std :: string fsm_action_command ( std :: string machine , std :: string command )
        {
            return machine + std :: string ( "_command_" ) + command ;
        }
        static std :: string fsm_actions_type_begin ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "    class _autogenerated_actions_type\n" )
                + std :: string ( "    {\n" )
                + std :: string ( "    public :\n" )
                + std :: string ( "        void set_fsm ( typename platform_pointer :: template pointer < " ) + fsm_system + std :: string ( "_fsm_autogenerated > ) ;\n" )
                + std :: string ( "\n" )
                ;
        }
        static std :: string fsm_actions_type_command_implementation ( std :: string fsm_system , std :: string action )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " ) + fsm_system + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: _autogenerated_actions_type :: " )
                    + action
                    + std :: string ( " ( )\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    platform_math :: make_num_whole ( _fsm . get ( ) . _current_autogenerated_inputs . machine_" )
                    + action
                    + std :: string ( " , true ) ;\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string fsm_actions_type_end ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "    private :\n" )
                + std :: string ( "        typename platform_pointer :: template pointer < " ) + fsm_system + std :: string ( "_fsm_autogenerated > _fsm ;\n" )
                + std :: string ( "    } ;\n" )
                ;
        }
        static std :: string fsm_actions_type_entry ( std :: string action )
        {
            return std :: string ( "        void " ) + action + std :: string ( " ( ) ;\n" ) ;
        }
        static std :: string fsm_actions_type_set_fsm_implementation ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "template < typename " ) + fsm_system + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: _autogenerated_actions_type :: set_fsm\n" )
                + std :: string ( "    ( typename platform_pointer :: template pointer < " )
                    + fsm_system + std :: string ( "_fsm_autogenerated > arg_fsm )\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    _fsm = arg_fsm ;\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string fsm_condition_and ( )
        {
            return std :: string ( " && " ) ;
        }
        static std :: string fsm_condition_command_implementation ( std :: string machine , std :: string command )
        {
            return std :: string ( )
                + std :: string ( "platform_conditions :: whole_is_true ( env . autogenerated_inputs . get ( ) . " )
                + std :: string ( "machine_" )
                + machine
                + std :: string ( "_command_" )
                + command
                + std :: string ( " )" )
                ;
        }
        static std :: string fsm_condition_implementation_begin ( std :: string conditions )
        {
            return std :: string ( )
                + std :: string ( "    if ( " ) + conditions + std :: string ( " )\n" )
                + std :: string ( "    {\n" )
                ;
        }
        static std :: string fsm_condition_implementation_begin_else ( std :: string conditions )
        {
            return std :: string ( )
                + std :: string ( "    else if ( " ) + conditions + std :: string ( " )\n" )
                + std :: string ( "    {\n" )
                ;
        }
        static std :: string fsm_condition_group_begin ( )
        {
            return std :: string ( "( " ) ;
        }
        static std :: string fsm_condition_group_end ( )
        {
            return std :: string ( " )" ) ;
        }
        static std :: string fsm_condition_input_implementation ( std :: string input )
        {
            return std :: string ( )
                + std :: string ( "platform_conditions :: whole_is_true ( env . inputs . get ( ) . " ) 
                + input 
                + std :: string ( " )" )
                ;
        }
        static std :: string fsm_condition_implementation_end ( )
        {
            return std :: string ( "    }\n" ) ;
        }
        static std :: string fsm_condition_or ( )
        {
            return std :: string ( " || " ) ;
        } 
        static std :: string fsm_condition_state_implementation ( std :: string machine , std :: string state )
        {
            return std :: string ( )
                + std :: string ( "platform_conditions :: whole_is_true ( env . autogenerated_inputs . get ( ) . " )
                + std :: string ( "machine_" )
                + machine
                + std :: string ( "_state_is_" )
                + state
                + std :: string ( " )" )
                ;
        }
        static std :: string fsm_constructor_implementation_begin ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " ) + fsm_system + std :: string ( "_fsm >\n" )
                + std :: string ( "shy_" ) 
                    + fsm_system 
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated ( )\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    typename platform_pointer :: template pointer < " )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated > fsm ;\n" )
                + std :: string ( "    platform_pointer :: bind ( fsm , * this ) ;\n" )
                + std :: string ( "    _autogenerated_actions . set_fsm ( fsm ) ;\n" )
                + std :: string ( "\n" )
                + std :: string ( "    platform_pointer :: bind ( _state_environment . autogenerated_actions , _autogenerated_actions ) ;\n" )
                + std :: string ( "    platform_pointer :: bind ( _state_environment . autogenerated_inputs , _fixed_autogenerated_inputs ) ;\n" )
                + std :: string ( "    platform_pointer :: bind ( _state_environment . states , _states ) ;\n" )
                + std :: string ( "\n" )
                + std :: string ( "    platform_math :: make_num_whole ( _fsm_running , false ) ;\n" )
                + std :: string ( "\n" )
                ;
        }
        static std :: string fsm_constructor_implementation_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string fsm_constructor_implementation_initial_state ( std :: string machine )
        {
            return std :: string ( )
                + std :: string ( "    platform_pointer :: bind ( _machine_" )
                + machine
                + std :: string ( "_state , _states . " )
                + machine
                + std :: string ( "_state_initial ) ;\n" )
                ;
        }
        static std :: string fsm_determine_inputs_change_begin ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " )
                    + fsm_system
                    + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: determine_autogenerated_inputs_change ( num_whole & inputs_changed )\n" )
                + std :: string ( "{\n" )
                ;
        }
        static std :: string fsm_determine_inputs_change_end ( )
        {
            return std :: string ( )
                + std :: string ( "       )\n" )
                + std :: string ( "    {\n" )
                + std :: string ( "        platform_math :: make_num_whole ( inputs_changed , false ) ;\n" )
                + std :: string ( "    }\n" )
                + std :: string ( "    else\n" )
                + std :: string ( "        platform_math :: make_num_whole ( inputs_changed , true ) ;\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string fsm_determine_inputs_change_entry_first ( std :: string input )
        {
            return std :: string ( )
                + std :: string ( "    if ( platform_conditions :: wholes_are_equal ( _current_autogenerated_inputs . " )
                + input
                + std :: string ( " , _fixed_autogenerated_inputs . " )
                + input
                + std :: string ( " )\n" )
                ;
        }
        static std :: string fsm_determine_inputs_change_entry_next ( std :: string input )
        {
            return std :: string ( )
                + std :: string ( "      && platform_conditions :: wholes_are_equal ( _current_autogenerated_inputs . " )
                + input
                + std :: string ( " , _fixed_autogenerated_inputs . " )
                + input
                + std :: string ( " )\n" )
                ;
        }
        static std :: string fsm_input_command ( std :: string machine , std :: string command )
        {
            return std :: string ( "machine_" ) + machine + std :: string ( "_command_" ) + command ;
        }
        static std :: string fsm_input_state ( std :: string machine , std :: string state )
        {
            return std :: string ( "machine_" ) + machine + std :: string ( "_state_is_" ) + state ;
        }
        static std :: string fsm_inputs_type_begin ( )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "    class _autogenerated_inputs_type\n" )
                + std :: string ( "    {\n" ) 
                + std :: string ( "    public :\n" ) 
                ;
        }
        static std :: string fsm_inputs_type_end ( )
        {
            return std :: string ( "    } ;\n" ) ;
        }
        static std :: string fsm_inputs_type_entry ( std :: string input )
        {
            return std :: string ( "        num_whole " ) + input + std :: string ( " ;\n" ) ;
        }
        static std :: string fsm_is_running ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " )
                    + fsm_system
                    + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: is_fsm_running ( num_whole & result )\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    result = _fsm_running ;\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string fsm_machine_attribute ( std :: string machine )
        {
            return std :: string ( ) 
                + std :: string ( "    typename platform_pointer :: template pointer < _state_type > _machine_" )
                + machine
                + std :: string ( "_state ;\n" )
                ;
        }
        static std :: string fsm_machine_state_destructor
            ( std :: string fsm_system 
            , std :: string fsm_machine 
            , std :: string fsm_state 
            )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " ) + fsm_system + std :: string ( "_fsm >\n" )
                + std :: string ( "shy_" ) 
                    + fsm_system 
                    + std :: string ( "_fsm_autogenerated < " ) 
                    + fsm_system
                    + std :: string ( "_fsm > :: _machine_" )
                    + fsm_machine
                    + std :: string ( "_state_" )
                    + fsm_state
                    + std :: string ( "_type :: ~ _machine_" )
                    + fsm_machine
                    + std :: string ( "_state_" )
                    + fsm_state
                    + std :: string ( "_type ( )\n" )
                + std :: string ( "{\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string fsm_machine_state_on_entry_implementation_begin 
            ( std :: string fsm_system 
            , std :: string fsm_machine 
            , std :: string fsm_state 
            )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " ) + fsm_system + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" ) 
                    + fsm_system 
                    + std :: string ( "_fsm_autogenerated < " ) 
                    + fsm_system
                    + std :: string ( "_fsm > :: _machine_" )
                    + fsm_machine
                    + std :: string ( "_state_" )
                    + fsm_state
                    + std :: string ( "_type :: on_entry ( _state_environment_type & env )\n" )
                + std :: string ( "{\n" )
                ;
        }
        static std :: string fsm_machine_state_on_entry_implementation_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string fsm_machine_state_on_exit_implementation_begin 
            ( std :: string fsm_system 
            , std :: string fsm_machine 
            , std :: string fsm_state 
            )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " ) + fsm_system + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" ) 
                    + fsm_system 
                    + std :: string ( "_fsm_autogenerated < " ) 
                    + fsm_system
                    + std :: string ( "_fsm > :: _machine_" )
                    + fsm_machine
                    + std :: string ( "_state_" )
                    + fsm_state
                    + std :: string ( "_type :: on_exit ( _state_environment_type & env )\n" )
                + std :: string ( "{\n" )
                ;
        }
        static std :: string fsm_machine_state_on_exit_implementation_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string fsm_machine_state_on_input_implementation_begin 
            ( std :: string fsm_system 
            , std :: string fsm_machine 
            , std :: string fsm_state 
            )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " ) + fsm_system + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" ) 
                    + fsm_system 
                    + std :: string ( "_fsm_autogenerated < " ) 
                    + fsm_system
                    + std :: string ( "_fsm > :: _machine_" )
                    + fsm_machine
                    + std :: string ( "_state_" )
                    + fsm_state
                    + std :: string ( "_type :: on_input ( _state_environment_type & env )\n" )
                + std :: string ( "{\n" )
                ;
        }
        static std :: string fsm_machine_state_on_input_implementation_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string fsm_machine_state_transition_implementation_begin 
            ( std :: string fsm_system 
            , std :: string fsm_machine 
            , std :: string fsm_state 
            )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " ) + fsm_system + std :: string ( "_fsm >\n" )
                + std :: string ( "typename shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: _state_type &\n" )
                + std :: string ( "shy_" ) 
                    + fsm_system 
                    + std :: string ( "_fsm_autogenerated < " ) 
                    + fsm_system
                    + std :: string ( "_fsm > :: _machine_" )
                    + fsm_machine
                    + std :: string ( "_state_" )
                    + fsm_state
                    + std :: string ( "_type :: transition ( _state_environment_type & env )\n" )
                + std :: string ( "{\n" )
                ;
        }
        static std :: string fsm_machine_state_transition_implementation_end ( )
        {
            return std :: string ( )
                + std :: string ( "    else\n" )
                + std :: string ( "        return _state_type :: transition ( env ) ;\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string fsm_machine_state_transition_implementation_end_always ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string fsm_machine_state_type_begin ( std :: string machine , std :: string state )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "    class _machine_" ) + machine + std :: string ( "_state_" ) + state + std :: string ( "_type\n" )
                + std :: string ( "    : public _state_type\n" )
                + std :: string ( "    {\n" )
                + std :: string ( "    public :\n" )
                + std :: string ( "        virtual ~ _machine_" ) + machine + std :: string ( "_state_" ) + state + std :: string ( "_type ( ) ;\n" )
                ;
        }
        static std :: string fsm_machine_state_type_end ( )
        {
            return std :: string ( "    } ;\n" ) ;
        }
        static std :: string fsm_machine_state_type_on_entry ( )
        {
            return std :: string ( "        virtual void on_entry ( _state_environment_type & ) ;\n" ) ;
        }
        static std :: string fsm_machine_state_type_on_exit ( )
        {
            return std :: string ( "        virtual void on_exit ( _state_environment_type & ) ;\n" ) ;
        }
        static std :: string fsm_machine_state_type_on_input ( )
        {
            return std :: string ( "        virtual void on_input ( _state_environment_type & ) ;\n" ) ;
        }
        static std :: string fsm_machine_state_type_transition ( )
        {
            return std :: string ( "        virtual _state_type & transition ( _state_environment_type & ) ;\n" ) ;
        }
        static std :: string fsm_on_input_actions_indentation ( )
        {
            return std :: string ( "    " ) ;
        }
        static std :: string fsm_private_section ( )
        {
            return std :: string ( "private :\n" ) ;
        }
        static std :: string fsm_public_methods ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "public :\n" )
                + std :: string ( "    shy_" ) + fsm_system + std :: string ( "_fsm_autogenerated ( ) ;\n" )
                + std :: string ( "    void set_inputs ( typename platform_pointer :: template pointer < inputs_type > ) ;\n" )
                + std :: string ( "    void set_actions ( typename platform_pointer :: template pointer < actions_type > ) ;\n" )
                + std :: string ( "    void is_fsm_running ( num_whole & ) ;\n" )
                + std :: string ( "    void run_fsm_begin ( ) ;\n" )
                + std :: string ( "    void run_fsm_end ( ) ;\n" )
                + std :: string ( "    void reset_autogenerated_input_events ( ) ;\n" )
                + std :: string ( "    void recalc_current_autogenerated_inputs ( ) ;\n" )
                + std :: string ( "    void determine_autogenerated_inputs_change ( num_whole & ) ;\n" )
                + std :: string ( "    void update_fixed_autogenerated_inputs ( ) ;\n" )
                + std :: string ( "    void tick_all_fsms ( ) ;\n" )
                ;
        }
        static std :: string fsm_recalc_inputs_begin ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " )
                    + fsm_system
                    + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: recalc_current_autogenerated_inputs ( )\n" )
                + std :: string ( "{\n" )
                ;
        }
        static std :: string fsm_recalc_inputs_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string fsm_recalc_inputs_entry ( std :: string machine , std :: string state )
        {
            return std :: string ( )
                + std :: string ( "    platform_pointer :: is_bound_to ( _current_autogenerated_inputs . machine_" )
                + machine
                + std :: string ( "_state_is_" )
                + state
                + std :: string ( " , _machine_" )
                + machine
                + std :: string ( "_state , _states . " )
                + machine
                + std :: string ( "_state_" )
                + state
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string fsm_reset_input_event ( std :: string action )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_whole ( _current_autogenerated_inputs . machine_" )
                + action
                + std :: string ( " , false ) ;\n" )
                ;
        }
        static std :: string fsm_reset_input_events_begin ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " )
                    + fsm_system
                    + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: reset_autogenerated_input_events ( )\n" )
                + std :: string ( "{\n" )
                ;
        }
        static std :: string fsm_reset_input_events_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string fsm_run_begin ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " )
                    + fsm_system
                    + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: run_fsm_begin ( )\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    platform_math :: make_num_whole ( _fsm_running , true ) ;\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string fsm_run_end ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " )
                    + fsm_system
                    + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: run_fsm_end ( )\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    platform_math :: make_num_whole ( _fsm_running , false ) ;\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string fsm_set_actions_implementation ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " )
                    + fsm_system
                    + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: set_actions ( typename platform_pointer :: template pointer < actions_type > actions )\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    _state_environment . actions = actions ;\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string fsm_set_inputs_implementation ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "template < typename " )
                    + fsm_system
                    + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: set_inputs ( typename platform_pointer :: template pointer < inputs_type > inputs )\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    _state_environment . inputs = inputs ;\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string fsm_state_environment_type ( )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "    class _state_environment_type\n" )
                + std :: string ( "    {\n" )
                + std :: string ( "    public :\n" )
                + std :: string ( "        typename platform_pointer :: template pointer < _autogenerated_actions_type > autogenerated_actions ;\n" )
                + std :: string ( "        typename platform_pointer :: template pointer < actions_type > actions ;\n" )
                + std :: string ( "        typename platform_pointer :: template pointer < _states_type > states ;\n" )
                + std :: string ( "        typename platform_pointer :: template pointer < _autogenerated_inputs_type > autogenerated_inputs ;\n" )
                + std :: string ( "        typename platform_pointer :: template pointer < inputs_type > inputs ;\n" )
                + std :: string ( "    } ;\n" )
                ;
        }
        static std :: string fsm_states_type_begin ( )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "    class _states_type\n" )
                + std :: string ( "    {\n" )
                + std :: string ( "    public :\n" )
                ;
        }
        static std :: string fsm_states_type_end ( )
        {
            return std :: string ( "    } ;\n" ) ;
        }
        static std :: string fsm_states_type_entry ( std :: string machine , std :: string state )
        {
            return std :: string ( )
                + std :: string ( "        _machine_" )
                + machine
                + std :: string ( "_state_" )
                + state
                + std :: string ( "_type " )
                + machine
                + std :: string ( "_state_" )
                + state
                + std :: string ( " ;\n" )
                ;
        }
        static std :: string fsm_system_begin ( std :: string name )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " ) + name + std :: string ( "_fsm >\n" )
                + std :: string ( "class shy_" ) + name + std :: string ( "_fsm_autogenerated\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    class _state_environment_type ;\n" )
                + std :: string ( "    class _states_type ;\n" )
                + std :: string ( "\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: engine_fsm engine_fsm ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_conditions platform_conditions ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_math platform_math ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_math :: num_whole num_whole ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: mediator_type :: platform :: platform_pointer platform_pointer ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: actions_type actions_type ;\n" )
                + std :: string ( "    typedef typename logic_application_fsm :: inputs_type inputs_type ;\n" )
                + std :: string ( "\n" )
                + std :: string ( "    typedef typename engine_fsm :: template fsm_state_type < _state_environment_type > _state_type ;\n" )
                + std :: string ( "    typedef shy_" ) + name + std :: string ( "_fsm_autogenerated < " ) + name + std :: string ( "_fsm > " ) + name + std :: string ( "_fsm_autogenerated ;\n" ) ;
                ;
        }
        static std :: string fsm_system_end ( )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "    num_whole _fsm_running ;\n" )
                + std :: string ( "    _autogenerated_actions_type _autogenerated_actions ;\n" )
                + std :: string ( "    _states_type _states ;\n" )
                + std :: string ( "    _state_environment_type _state_environment ;\n" )
                + std :: string ( "    _autogenerated_inputs_type _current_autogenerated_inputs ;\n" )
                + std :: string ( "    _autogenerated_inputs_type _fixed_autogenerated_inputs ;\n" )
                + std :: string ( "} ;\n" )
                ;
        }
        static std :: string fsm_tick_begin ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " )
                    + fsm_system
                    + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: tick_all_fsms ( )\n" )
                + std :: string ( "{\n" )
                ;
        }
        static std :: string fsm_tick_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string fsm_tick_entry ( std :: string machine )
        {
            return std :: string ( )
                + std :: string ( "    engine_fsm :: tick_single_fsm ( _state_environment , _machine_" )
                + machine
                + std :: string ( "_state ) ;\n" )
                ;
        }
        static std :: string fsm_transition_always_implementation ( std :: string machine , std :: string state )
        {
            return std :: string ( )
                + std :: string ( "    return env . states . get ( ) . " )
                + machine
                + std :: string ( "_state_" )
                + state
                + std :: string ( " ;\n" )
                ;
        }
        static std :: string fsm_transition_always_implementation_else ( std :: string machine , std :: string state )
        {
            return std :: string ( )
                + std :: string ( "    else\n" )
                + std :: string ( "        return env . states . get ( ) . " )
                + machine
                + std :: string ( "_state_" )
                + state
                + std :: string ( " ;\n" )
                ;
        }
        static std :: string fsm_transition_conditional_implementation ( std :: string machine , std :: string state )
        {
            return std :: string ( )
                + std :: string ( "        return env . states . get ( ) . " )
                + machine
                + std :: string ( "_state_" )
                + state
                + std :: string ( " ;\n" )
                ;
        }
        static std :: string fsm_update_inputs ( std :: string fsm_system )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename " )
                    + fsm_system
                    + std :: string ( "_fsm >\n" )
                + std :: string ( "void shy_" )
                    + fsm_system
                    + std :: string ( "_fsm_autogenerated < " )
                    + fsm_system
                    + std :: string ( "_fsm > :: update_fixed_autogenerated_inputs ( )\n" )
                + std :: string ( "{\n" )
                + std :: string ( "    _fixed_autogenerated_inputs = _current_autogenerated_inputs ;\n" )
                + std :: string ( "}\n" )
                ;
        }
        static std :: string module_begin ( std :: string name )
        {
            return std :: string ( )
                + std :: string ( "\n" )
                + std :: string ( "template < typename mediator >\n" )
                + std :: string ( "shy_" ) + name + std :: string ( " < mediator >\n" )
                + std :: string ( ":: " ) + name + std :: string ( "_consts_type \n" )
                + std :: string ( ":: " ) + name + std :: string ( "_consts_type ( )\n" )
                + std :: string ( "{\n" )
                ;
        } ;
        static std :: string module_end ( )
        {
            return std :: string ( "}\n" ) ;
        }
        static std :: string set_fract_value ( std :: string name , std :: string numerator , std :: string denominator )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_fract ( " ) 
                + name 
                + std :: string ( " , " )
                + numerator
                + std :: string ( " , " )
                + denominator
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string set_whole_value ( std :: string name , std :: string value )
        {
            return std :: string ( )
                + std :: string ( "    platform_math :: make_num_whole ( " )
                + name
                + std :: string ( " , " )
                + value
                + std :: string ( " ) ;\n" )
                ;
        }
        static std :: string whitespace ( )
        {
            return std :: string ( " " ) ;
        }
    } ;

public :
    shy_data_generator ( ) ;
    void set_content ( const data_content & ) ;
    std :: string generate ( ) ;
private :
    void _generate_modules ( ) ;
    void _generate_fsm_systems ( ) ;
    void _generate_fsm_inputs_type ( ) ;
    void _generate_fsm_actions_type ( ) ;
    void _generate_fsm_machines_states_types ( ) ;
    void _generate_fsm_states_type ( ) ;
    void _generate_fsm_machines_attributes ( ) ;
    void _generate_fsm_machines_states_implementation ( ) ;
    void _generate_fsm_actions_type_implementation ( ) ;
    void _generate_fsm_constructor ( ) ;
    void _generate_fsm_reset_input_events ( ) ;
    void _generate_fsm_determine_inputs_change ( ) ;
    void _generate_fsm_recalc_inputs ( ) ;
    void _generate_fsm_tick ( ) ;
    void _generate_current_fsm_machine_state_on_entry_implementation ( ) ;
    void _generate_current_fsm_machine_state_on_exit_implementation ( ) ;
    void _generate_current_fsm_machine_state_on_input_implementation ( ) ;
    void _generate_current_fsm_machine_state_transition_implementation ( ) ;
    void _generate_fsm_actions_implementation ( const data_content_fsm_actions & , std :: string ) ;
    void _generate_fsm_conditions_implementation ( const data_content_fsm_condition_group_container & ) ;
    void _collect_fsm_inputs_from_actions ( const data_content_fsm_actions & ) ;
    void _collect_fsm_inputs_from_condition_groups ( std :: string , const data_content_fsm_condition_group_container & ) ;
    void _collect_fsm_recalc_inputs_entries_from_condition_groups ( std :: string , const data_content_fsm_condition_group_container & ) ;
    void _collect_fsm_actions ( const data_content_fsm_actions & ) ;
    bool _fsm_actions_empty ( const data_content_fsm_actions & ) ;
private :
    const data_content * _content ;
    const data_content_fsm_state * _current_fsm_state ;
    const data_content_fsm_system * _current_fsm_system ;
    std :: string _modules_code ;
    std :: string _fsm_systems_code ;
    std :: string _fsm_inputs_type_code ;
    std :: string _fsm_actions_type_code ;
    std :: string _fsm_machines_states_types_code ;
    std :: string _fsm_states_type_code ;
    std :: string _fsm_machines_attributes_code ;
    std :: string _fsm_machines_states_implementation_code ;
    std :: string _fsm_machine_state_on_entry_implementation_code ;
    std :: string _fsm_machine_state_on_exit_implementation_code ;
    std :: string _fsm_machine_state_on_input_implementation_code ;
    std :: string _fsm_machine_state_transition_implementation_code ;
    std :: string _fsm_actions_implementation_code ;
    std :: string _fsm_conditions_implementation_code ;
    std :: string _fsm_actions_type_implementation_code ;
    std :: string _fsm_constructor_code ;
    std :: string _fsm_reset_input_events_code ;
    std :: string _fsm_determine_inputs_change_code ;
    std :: string _fsm_recalc_inputs_code ;
    std :: string _fsm_tick_code ;
    std :: string _current_fsm_machine_name ;
    std :: string _current_fsm_state_name ;
    std :: string _current_fsm_system_name ;
    _collected_fsm_inputs_type _collected_fsm_inputs ;
    _collected_fsm_actions_type _collected_fsm_actions ;
    _collected_fsm_recalc_inputs_entries_type _collected_fsm_recalc_inputs_entries ;
} ;

template < typename data_generator_types >
shy_data_generator < data_generator_types > :: shy_data_generator ( )
: _content ( 0 )
, _current_fsm_state ( 0 )
, _current_fsm_system ( 0 )
{
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: set_content ( const data_content & content )
{
    _content = & content ;
}

template < typename data_generator_types >
std :: string shy_data_generator < data_generator_types > :: generate ( )
{
    _generate_modules ( ) ;
    _generate_fsm_systems ( ) ;

    return _consts :: file_begin ( )
         + _modules_code
         + _fsm_systems_code
         + _consts :: file_end ( )
         ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_modules ( )
{
    for ( typename data_content :: data_content_module_container :: const_iterator module_i = _content -> modules . begin ( )
        ; module_i != _content -> modules . end ( )
        ; ++ module_i
        )
    {
        std :: string module_name = module_i -> first ;
        const data_content_module & module = module_i -> second ;

        _modules_code += _consts :: module_begin ( module_name ) ;

        for ( typename data_content_whole_container :: const_iterator whole_i = module . name_to_whole . begin ( )
            ; whole_i != module . name_to_whole . end ( )
            ; ++ whole_i
            )
        {
            std :: string whole_name = whole_i -> first ;
            const data_content_whole & whole = whole_i -> second ;
            
            std :: string value ;
            value += whole . sign ;
            if ( ! value . empty ( ) )
                value += _consts :: whitespace ( ) ;
            value += whole . value ;

            _modules_code += _consts :: set_whole_value ( whole_name , value ) ;
        }
        for ( typename data_content_fract_container :: const_iterator fract_i = module . name_to_fract . begin ( )
            ; fract_i != module . name_to_fract . end ( )
            ; ++ fract_i
            )
        {
            std :: string fract_name = fract_i -> first ;
            const data_content_fract & fract = fract_i -> second ;
            
            std :: string numerator ;
            numerator += fract . numerator_sign ;
            if ( ! numerator . empty ( ) )
                numerator += _consts :: whitespace ( ) ;
            numerator += fract . numerator_value ;

            std :: string denominator ;
            denominator += fract . denominator_sign ;
            if ( ! denominator . empty ( ) )
                denominator += _consts :: whitespace ( ) ;
            denominator += fract . denominator_value ;

            _modules_code += _consts :: set_fract_value ( fract_name , numerator , denominator ) ;
        }
        _modules_code += _consts :: module_end ( ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_systems ( )
{
    for ( typename data_content_fsm_system_container :: const_iterator fsm_system_i = _content -> fsm_systems . begin ( )
        ; fsm_system_i != _content -> fsm_systems . end ( )
        ; ++ fsm_system_i
        )
    {
        std :: string fsm_system_name = fsm_system_i -> first ;
        const data_content_fsm_system & fsm_system = fsm_system_i -> second ;

        _current_fsm_system = & fsm_system ;
        _current_fsm_system_name = fsm_system_name ;

        _generate_fsm_inputs_type ( ) ;
        _generate_fsm_actions_type ( ) ;
        _generate_fsm_machines_states_types ( ) ;
        _generate_fsm_states_type ( ) ;
        _generate_fsm_machines_attributes ( ) ;
        _generate_fsm_machines_states_implementation ( ) ;
        _generate_fsm_actions_type_implementation ( ) ;
        _generate_fsm_constructor ( ) ;
        _generate_fsm_reset_input_events ( ) ;
        _generate_fsm_determine_inputs_change ( ) ;
        _generate_fsm_recalc_inputs ( ) ;
        _generate_fsm_tick ( ) ;

        _fsm_systems_code = _fsm_systems_code
            + _consts :: fsm_system_begin ( fsm_system_name )
            + _fsm_inputs_type_code
            + _fsm_actions_type_code
            + _consts :: fsm_state_environment_type ( )
            + _fsm_machines_states_types_code
            + _fsm_states_type_code
            + _consts :: fsm_public_methods ( fsm_system_name )
            + _consts :: fsm_private_section ( )
            + _fsm_machines_attributes_code
            + _consts :: fsm_system_end ( )
            + _fsm_machines_states_implementation_code
            + _fsm_actions_type_implementation_code
            + _fsm_constructor_code
            + _consts :: fsm_set_actions_implementation ( fsm_system_name )
            + _consts :: fsm_set_inputs_implementation ( fsm_system_name )
            + _fsm_reset_input_events_code
            + _fsm_determine_inputs_change_code
            + _fsm_recalc_inputs_code
            + _consts :: fsm_update_inputs ( fsm_system_name )
            + _fsm_tick_code
            + _consts :: fsm_is_running ( fsm_system_name )
            + _consts :: fsm_run_begin ( fsm_system_name )
            + _consts :: fsm_run_end ( fsm_system_name )
            ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_inputs_type ( )
{
    _collected_fsm_inputs . clear ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        std :: string fsm_machine_name = fsm_machine_i -> first ;
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;
        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
            const data_content_fsm_state & fsm_state = fsm_state_i -> second ;
            _collect_fsm_inputs_from_actions ( fsm_state . on_entry ) ;
            _collect_fsm_inputs_from_actions ( fsm_state . on_exit ) ;
            for ( typename data_content_fsm_on_input_container :: const_iterator fsm_on_input_i = fsm_state . on_input . begin ( )
                ; fsm_on_input_i != fsm_state . on_input . end ( )
                ; ++ fsm_on_input_i
                )
            {
                const data_content_fsm_on_input & fsm_on_input = * fsm_on_input_i ;
                _collect_fsm_inputs_from_condition_groups ( fsm_machine_name , fsm_on_input . condition_groups ) ;
                _collect_fsm_inputs_from_actions ( fsm_on_input . actions ) ;
            }
            for ( typename data_content_fsm_transition_container :: const_iterator fsm_transition_i = fsm_state . transitions . begin ( )
                ; fsm_transition_i != fsm_state . transitions . end ( )
                ; ++ fsm_transition_i
                )
            {
                const data_content_fsm_transition & fsm_transition = * fsm_transition_i ;
                _collect_fsm_inputs_from_condition_groups ( fsm_machine_name , fsm_transition . condition_groups ) ;
            }
        }
    }

    _fsm_inputs_type_code = _consts :: fsm_inputs_type_begin ( ) ;

    for ( typename _collected_fsm_inputs_type :: const_iterator collected_input_i = _collected_fsm_inputs . begin ( )
        ; collected_input_i != _collected_fsm_inputs . end ( )
        ; ++ collected_input_i
        )
    {
        _fsm_inputs_type_code += _consts :: fsm_inputs_type_entry ( * collected_input_i ) ;
    }

    _fsm_inputs_type_code += _consts :: fsm_inputs_type_end ( ) ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _collect_fsm_inputs_from_actions ( const data_content_fsm_actions & actions )
{
    for ( typename data_content_fsm_action_command_container :: const_iterator command_i = actions . commands . begin ( )
        ; command_i != actions . commands . end ( )
        ; ++ command_i
        )
    {
        const data_content_fsm_action_command & command = * command_i ;
        _collected_fsm_inputs . insert ( _consts :: fsm_input_command ( command . machine , command . command ) ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _collect_fsm_inputs_from_condition_groups 
    ( std :: string fsm_machine_name
    , const data_content_fsm_condition_group_container & condition_groups
    )
{
    for ( typename data_content_fsm_condition_group_container :: const_iterator condition_group_i = condition_groups . begin ( )
        ; condition_group_i != condition_groups . end ( )
        ; ++ condition_group_i
        )
    {
        const data_content_fsm_condition_group & condition_group = * condition_group_i ;
        for ( typename data_content_fsm_condition_state_container :: const_iterator condition_state_i = condition_group . states . begin ( )
            ; condition_state_i != condition_group . states . end ( )
            ; ++ condition_state_i
            )
        {
            const data_content_fsm_condition_state & condition_state = * condition_state_i ;
            _collected_fsm_inputs . insert ( _consts :: fsm_input_state ( condition_state . machine , condition_state . state ) ) ;
        }
        for ( typename data_content_fsm_condition_command_container :: const_iterator condition_command_i = condition_group . commands . begin ( )
            ; condition_command_i != condition_group . commands . end ( )
            ; ++ condition_command_i
            )
        {
            const data_content_fsm_condition_command & condition_command = * condition_command_i ;
            _collected_fsm_inputs . insert ( _consts :: fsm_input_command ( fsm_machine_name , condition_command . command ) ) ;
        }
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _collect_fsm_recalc_inputs_entries_from_condition_groups 
    ( std :: string fsm_machine_name
    , const data_content_fsm_condition_group_container & condition_groups
    )
{
    for ( typename data_content_fsm_condition_group_container :: const_iterator condition_group_i = condition_groups . begin ( )
        ; condition_group_i != condition_groups . end ( )
        ; ++ condition_group_i
        )
    {
        const data_content_fsm_condition_group & condition_group = * condition_group_i ;
        for ( typename data_content_fsm_condition_state_container :: const_iterator condition_state_i = condition_group . states . begin ( )
            ; condition_state_i != condition_group . states . end ( )
            ; ++ condition_state_i
            )
        {
            const data_content_fsm_condition_state & condition_state = * condition_state_i ;
            _collected_fsm_recalc_inputs_entries . insert ( _consts :: fsm_recalc_inputs_entry ( condition_state . machine , condition_state . state ) ) ;
        }
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_actions_type ( )
{
    _collected_fsm_actions . clear ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;
        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
            const data_content_fsm_state & fsm_state = fsm_state_i -> second ;
            _collect_fsm_actions ( fsm_state . on_entry ) ;
            _collect_fsm_actions ( fsm_state . on_exit ) ;
            for ( typename data_content_fsm_on_input_container :: const_iterator fsm_on_input_i = fsm_state . on_input . begin ( )
                ; fsm_on_input_i != fsm_state . on_input . end ( )
                ; ++ fsm_on_input_i
                )
            {
                const data_content_fsm_on_input & fsm_on_input = * fsm_on_input_i ;
                _collect_fsm_actions ( fsm_on_input . actions ) ;
            }
        }
    }

    _fsm_actions_type_code = _consts :: fsm_actions_type_begin ( _current_fsm_system_name ) ;

    for ( typename _collected_fsm_actions_type :: const_iterator collected_action_i = _collected_fsm_actions . begin ( )
        ; collected_action_i != _collected_fsm_actions . end ( )
        ; ++ collected_action_i
        )
    {
        _fsm_actions_type_code += _consts :: fsm_actions_type_entry ( * collected_action_i ) ;
    }

    _fsm_actions_type_code += _consts :: fsm_actions_type_end ( _current_fsm_system_name ) ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _collect_fsm_actions ( const data_content_fsm_actions & actions )
{
    for ( typename data_content_fsm_action_command_container :: const_iterator command_i = actions . commands . begin ( )
        ; command_i != actions . commands . end ( )
        ; ++ command_i
        )
    {
        const data_content_fsm_action_command & command = * command_i ;
        _collected_fsm_actions . insert ( _consts :: fsm_action_command ( command . machine , command . command ) ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_machines_states_types ( )
{
    _fsm_machines_states_types_code = std :: string ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        std :: string fsm_machine_name = fsm_machine_i -> first ;
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;
        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
            std :: string fsm_state_name = fsm_state_i -> first ;
            const data_content_fsm_state & fsm_state = fsm_state_i -> second ;

            _fsm_machines_states_types_code += _consts :: fsm_machine_state_type_begin ( fsm_machine_name , fsm_state_name ) ;

            if ( ! _fsm_actions_empty ( fsm_state . on_entry ) )
                _fsm_machines_states_types_code += _consts :: fsm_machine_state_type_on_entry ( ) ;
            if ( ! _fsm_actions_empty ( fsm_state . on_exit ) )
                _fsm_machines_states_types_code += _consts :: fsm_machine_state_type_on_exit ( ) ;
            if ( ! fsm_state . on_input . empty ( ) )
                _fsm_machines_states_types_code += _consts :: fsm_machine_state_type_on_input ( ) ;
            if ( ! fsm_state . transitions . empty ( ) )
                _fsm_machines_states_types_code += _consts :: fsm_machine_state_type_transition ( ) ;

            _fsm_machines_states_types_code += _consts :: fsm_machine_state_type_end ( ) ;
        }
    }
}

template < typename data_generator_types >
bool shy_data_generator < data_generator_types > :: _fsm_actions_empty ( const data_content_fsm_actions & actions )
{
    return actions . actions . empty ( ) && actions . commands . empty ( ) ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_states_type ( )
{
    _fsm_states_type_code = _consts :: fsm_states_type_begin ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        std :: string fsm_machine_name = fsm_machine_i -> first ;
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;
        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
            std :: string fsm_state_name = fsm_state_i -> first ;
            _fsm_states_type_code += _consts :: fsm_states_type_entry ( fsm_machine_name , fsm_state_name ) ;
        }
    }

    _fsm_states_type_code += _consts :: fsm_states_type_end ( ) ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_machines_attributes ( )
{
    _fsm_machines_attributes_code = std :: string ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        std :: string fsm_machine_name = fsm_machine_i -> first ;
        _fsm_machines_attributes_code += _consts :: fsm_machine_attribute ( fsm_machine_name ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_machines_states_implementation ( )
{
    _fsm_machines_states_implementation_code = std :: string ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        std :: string fsm_machine_name = fsm_machine_i -> first ;
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;

        _current_fsm_machine_name = fsm_machine_name ;

        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
            std :: string fsm_state_name = fsm_state_i -> first ;
            const data_content_fsm_state & fsm_state = fsm_state_i -> second ;

            _current_fsm_state = & fsm_state ;
            _current_fsm_state_name = fsm_state_name ;

            _generate_current_fsm_machine_state_on_entry_implementation ( ) ;
            _generate_current_fsm_machine_state_on_exit_implementation ( ) ;
            _generate_current_fsm_machine_state_on_input_implementation ( ) ;
            _generate_current_fsm_machine_state_transition_implementation ( ) ;

            _fsm_machines_states_implementation_code += _consts :: fsm_machine_state_destructor
                ( _current_fsm_system_name
                , fsm_machine_name
                , fsm_state_name
                ) ;
            _fsm_machines_states_implementation_code += _fsm_machine_state_on_entry_implementation_code ;
            _fsm_machines_states_implementation_code += _fsm_machine_state_on_exit_implementation_code ;
            _fsm_machines_states_implementation_code += _fsm_machine_state_on_input_implementation_code ;
            _fsm_machines_states_implementation_code += _fsm_machine_state_transition_implementation_code ;
        }
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_current_fsm_machine_state_on_entry_implementation ( )
{
    _fsm_machine_state_on_entry_implementation_code = std :: string ( ) ;
    if ( ! _fsm_actions_empty ( _current_fsm_state -> on_entry ) )
    {
        _generate_fsm_actions_implementation ( _current_fsm_state -> on_entry , std :: string ( ) ) ;

        _fsm_machine_state_on_entry_implementation_code +=
            _consts :: fsm_machine_state_on_entry_implementation_begin 
                ( _current_fsm_system_name 
                , _current_fsm_machine_name 
                , _current_fsm_state_name 
                ) ;
        _fsm_machine_state_on_entry_implementation_code +=
            _fsm_actions_implementation_code ;
        _fsm_machine_state_on_entry_implementation_code +=
            _consts :: fsm_machine_state_on_entry_implementation_end ( ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_current_fsm_machine_state_on_exit_implementation ( )
{
    _fsm_machine_state_on_exit_implementation_code = std :: string ( ) ;
    if ( ! _fsm_actions_empty ( _current_fsm_state -> on_exit ) )
    {
        _generate_fsm_actions_implementation ( _current_fsm_state -> on_exit , std :: string ( ) ) ;

        _fsm_machine_state_on_exit_implementation_code +=
            _consts :: fsm_machine_state_on_exit_implementation_begin 
                ( _current_fsm_system_name 
                , _current_fsm_machine_name 
                , _current_fsm_state_name 
                ) ;
        _fsm_machine_state_on_exit_implementation_code +=
            _fsm_actions_implementation_code ;
        _fsm_machine_state_on_exit_implementation_code +=
            _consts :: fsm_machine_state_on_exit_implementation_end ( ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_current_fsm_machine_state_on_input_implementation ( )
{
    _fsm_machine_state_on_input_implementation_code = std :: string ( ) ;
    if ( ! _current_fsm_state -> on_input . empty ( ) )
    {
        _fsm_machine_state_on_input_implementation_code +=
            _consts :: fsm_machine_state_on_input_implementation_begin 
                ( _current_fsm_system_name 
                , _current_fsm_machine_name 
                , _current_fsm_state_name 
                ) ;
        for ( typename data_content_fsm_on_input_container :: const_iterator on_input_i = _current_fsm_state -> on_input . begin ( )
            ; on_input_i != _current_fsm_state -> on_input . end ( )
            ; ++ on_input_i
            )
        {
            const data_content_fsm_on_input & on_input = * on_input_i ;

            _generate_fsm_conditions_implementation ( on_input . condition_groups ) ;
            _generate_fsm_actions_implementation ( on_input . actions , _consts :: fsm_on_input_actions_indentation ( ) ) ;

            _fsm_machine_state_on_input_implementation_code +=
                _consts :: fsm_condition_implementation_begin ( _fsm_conditions_implementation_code ) ;
            _fsm_machine_state_on_input_implementation_code +=
                _fsm_actions_implementation_code ;
            _fsm_machine_state_on_input_implementation_code +=
                _consts :: fsm_condition_implementation_end ( ) ;
        }
        _fsm_machine_state_on_input_implementation_code +=
            _consts :: fsm_machine_state_on_input_implementation_end ( ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_current_fsm_machine_state_transition_implementation ( )
{
    _fsm_machine_state_transition_implementation_code = std :: string ( ) ;
    if ( ! _current_fsm_state -> transitions . empty ( ) )
    {
        _fsm_machine_state_transition_implementation_code +=
            _consts :: fsm_machine_state_transition_implementation_begin 
                ( _current_fsm_system_name 
                , _current_fsm_machine_name 
                , _current_fsm_state_name 
                ) ;
        bool transition_always = false ;
        for ( typename data_content_fsm_transition_container :: const_iterator transition_i = _current_fsm_state -> transitions . begin ( )
            ; transition_i != _current_fsm_state -> transitions . end ( )
            ; ++ transition_i
            )
        {
            bool first_entry = transition_i == _current_fsm_state -> transitions . begin ( ) ;
            const data_content_fsm_transition & transition = * transition_i ;

            transition_always = transition . condition_groups . empty ( ) ;

            if ( first_entry )
            {
                if ( transition_always )
                {
                    _fsm_machine_state_transition_implementation_code +=
                        _consts :: fsm_transition_always_implementation ( _current_fsm_machine_name , transition . state ) ;
                    break ;
                }
                else
                {
                    _generate_fsm_conditions_implementation ( transition . condition_groups ) ;
                    _fsm_machine_state_transition_implementation_code +=
                        _consts :: fsm_condition_implementation_begin ( _fsm_conditions_implementation_code ) ;
                    _fsm_machine_state_transition_implementation_code +=
                        _consts :: fsm_transition_conditional_implementation ( _current_fsm_machine_name , transition . state ) ;
                    _fsm_machine_state_transition_implementation_code +=
                        _consts :: fsm_condition_implementation_end ( ) ;
                }
            }
            else
            {
                if ( transition_always )
                {
                    _fsm_machine_state_transition_implementation_code +=
                        _consts :: fsm_transition_always_implementation_else ( _current_fsm_machine_name , transition . state ) ;
                    break ;
                }
                else
                {
                    _generate_fsm_conditions_implementation ( transition . condition_groups ) ;
                    _fsm_machine_state_transition_implementation_code +=
                        _consts :: fsm_condition_implementation_begin_else ( _fsm_conditions_implementation_code ) ;
                    _fsm_machine_state_transition_implementation_code +=
                        _consts :: fsm_transition_conditional_implementation ( _current_fsm_machine_name , transition . state ) ;
                    _fsm_machine_state_transition_implementation_code +=
                        _consts :: fsm_condition_implementation_end ( ) ;
                }
            }
        }
        if ( transition_always )
        {
            _fsm_machine_state_transition_implementation_code +=
                _consts :: fsm_machine_state_transition_implementation_end_always ( ) ;
        }
        else
        {
            _fsm_machine_state_transition_implementation_code +=
                _consts :: fsm_machine_state_transition_implementation_end ( ) ;
        }
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_actions_implementation 
    ( const data_content_fsm_actions & actions 
    , std :: string indentation
    )
{
    _fsm_actions_implementation_code = std :: string ( ) ;
    for ( typename data_content_fsm_action_do_container :: const_iterator action_do_i = actions . actions . begin ( )
        ; action_do_i != actions . actions . end ( )
        ; ++ action_do_i
        )
    {
        const data_content_fsm_action_do & action_do = * action_do_i ;
        _fsm_actions_implementation_code += indentation ;
        _fsm_actions_implementation_code +=
            _consts :: fsm_action_do_implementation ( action_do . action ) ;
    } 
    for ( typename data_content_fsm_action_command_container :: const_iterator action_command_i = actions . commands . begin ( )
        ; action_command_i != actions . commands . end ( )
        ; ++ action_command_i
        )
    {
        const data_content_fsm_action_command & action_command = * action_command_i ;
        _fsm_actions_implementation_code += indentation ;
        _fsm_actions_implementation_code +=
            _consts :: fsm_action_command_implementation ( action_command . machine , action_command . command ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_conditions_implementation ( const data_content_fsm_condition_group_container & group_container )
{
    _fsm_conditions_implementation_code = std :: string ( ) ;
    for ( typename data_content_fsm_condition_group_container :: const_iterator condition_group_i = group_container . begin ( )
        ; condition_group_i != group_container . end ( )
        ; ++ condition_group_i
        )
    {
        bool next_condition = false ;
        bool next_group = condition_group_i != group_container . begin ( ) ;
        const data_content_fsm_condition_group & condition_group = * condition_group_i ;

        if ( next_group )
            _fsm_conditions_implementation_code += _consts :: fsm_condition_or ( ) ;
        if ( group_container . size ( ) > 1 )
            _fsm_conditions_implementation_code += _consts :: fsm_condition_group_begin ( ) ;

        for ( typename data_content_fsm_condition_input_container :: const_iterator condition_input_i = condition_group . inputs . begin ( )
            ; condition_input_i != condition_group . inputs . end ( )
            ; ++ condition_input_i
            )
        {
            const data_content_fsm_condition_input & condition_input = * condition_input_i ;
            std :: string input = condition_input . input ;

            if ( next_condition )
                _fsm_conditions_implementation_code += _consts :: fsm_condition_and ( ) ;
            else
                next_condition = true ;
            _fsm_conditions_implementation_code += _consts :: fsm_condition_input_implementation ( input ) ;
        }

        for ( typename data_content_fsm_condition_command_container :: const_iterator condition_command_i = condition_group . commands . begin ( )
            ; condition_command_i != condition_group . commands . end ( )
            ; ++ condition_command_i
            )
        {
            const data_content_fsm_condition_command & condition_command = * condition_command_i ;
            std :: string command = condition_command . command ;

            if ( next_condition )
                _fsm_conditions_implementation_code += _consts :: fsm_condition_and ( ) ;
            else
                next_condition = true ;
            _fsm_conditions_implementation_code += _consts :: fsm_condition_command_implementation ( _current_fsm_machine_name , command ) ;
        }

        for ( typename data_content_fsm_condition_state_container :: const_iterator condition_state_i = condition_group . states . begin ( )
            ; condition_state_i != condition_group . states . end ( )
            ; ++ condition_state_i
            )
        {
            const data_content_fsm_condition_state & condition_state = * condition_state_i ;
            std :: string machine = condition_state . machine ;
            std :: string state = condition_state . state ;

            if ( next_condition )
                _fsm_conditions_implementation_code += _consts :: fsm_condition_and ( ) ;
            else
                next_condition = true ;
            _fsm_conditions_implementation_code += _consts :: fsm_condition_state_implementation ( machine , state ) ;
        }

        if ( group_container . size ( ) > 1 )
            _fsm_conditions_implementation_code += _consts :: fsm_condition_group_end ( ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_actions_type_implementation ( )
{
    _collected_fsm_actions . clear ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;
        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
            const data_content_fsm_state & fsm_state = fsm_state_i -> second ;
            _collect_fsm_actions ( fsm_state . on_entry ) ;
            _collect_fsm_actions ( fsm_state . on_exit ) ;
            for ( typename data_content_fsm_on_input_container :: const_iterator fsm_on_input_i = fsm_state . on_input . begin ( )
                ; fsm_on_input_i != fsm_state . on_input . end ( )
                ; ++ fsm_on_input_i
                )
            {
                const data_content_fsm_on_input & fsm_on_input = * fsm_on_input_i ;
                _collect_fsm_actions ( fsm_on_input . actions ) ;
            }
        }
    }

    _fsm_actions_type_implementation_code = _consts :: fsm_actions_type_set_fsm_implementation ( _current_fsm_system_name ) ;

    for ( typename _collected_fsm_actions_type :: const_iterator collected_action_i = _collected_fsm_actions . begin ( )
        ; collected_action_i != _collected_fsm_actions . end ( )
        ; ++ collected_action_i
        )
    {
        _fsm_actions_type_implementation_code += _consts :: fsm_actions_type_command_implementation ( _current_fsm_system_name , * collected_action_i ) ;
    }
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_constructor ( )
{
    _fsm_constructor_code = _consts :: fsm_constructor_implementation_begin ( _current_fsm_system_name ) ;
    for ( typename data_content_fsm_machine_container :: const_iterator machine_i = _current_fsm_system -> machines . begin ( )
        ; machine_i != _current_fsm_system -> machines . end ( )
        ; ++ machine_i
        )
    {
        std :: string machine_name = machine_i -> first ;
        _fsm_constructor_code += _consts :: fsm_constructor_implementation_initial_state ( machine_name ) ;
    }
    _fsm_constructor_code += _consts :: fsm_constructor_implementation_end ( ) ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_reset_input_events ( )
{
    _collected_fsm_actions . clear ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;
        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
            const data_content_fsm_state & fsm_state = fsm_state_i -> second ;
            _collect_fsm_actions ( fsm_state . on_entry ) ;
            _collect_fsm_actions ( fsm_state . on_exit ) ;
            for ( typename data_content_fsm_on_input_container :: const_iterator fsm_on_input_i = fsm_state . on_input . begin ( )
                ; fsm_on_input_i != fsm_state . on_input . end ( )
                ; ++ fsm_on_input_i
                )
            {
                const data_content_fsm_on_input & fsm_on_input = * fsm_on_input_i ;
                _collect_fsm_actions ( fsm_on_input . actions ) ;
            }
        }
    }

    _fsm_reset_input_events_code = _consts :: fsm_reset_input_events_begin ( _current_fsm_system_name ) ;

    for ( typename _collected_fsm_actions_type :: const_iterator collected_action_i = _collected_fsm_actions . begin ( )
        ; collected_action_i != _collected_fsm_actions . end ( )
        ; ++ collected_action_i
        )
    {
        _fsm_reset_input_events_code += _consts :: fsm_reset_input_event ( * collected_action_i ) ;
    }

    _fsm_reset_input_events_code += _consts :: fsm_reset_input_events_end ( ) ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_determine_inputs_change ( )
{
    _collected_fsm_inputs . clear ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        std :: string fsm_machine_name = fsm_machine_i -> first ;
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;
        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
            const data_content_fsm_state & fsm_state = fsm_state_i -> second ;
            _collect_fsm_inputs_from_actions ( fsm_state . on_entry ) ;
            _collect_fsm_inputs_from_actions ( fsm_state . on_exit ) ;
            for ( typename data_content_fsm_on_input_container :: const_iterator fsm_on_input_i = fsm_state . on_input . begin ( )
                ; fsm_on_input_i != fsm_state . on_input . end ( )
                ; ++ fsm_on_input_i
                )
            {
                const data_content_fsm_on_input & fsm_on_input = * fsm_on_input_i ;
                _collect_fsm_inputs_from_condition_groups ( fsm_machine_name , fsm_on_input . condition_groups ) ;
                _collect_fsm_inputs_from_actions ( fsm_on_input . actions ) ;
            }
            for ( typename data_content_fsm_transition_container :: const_iterator fsm_transition_i = fsm_state . transitions . begin ( )
                ; fsm_transition_i != fsm_state . transitions . end ( )
                ; ++ fsm_transition_i
                )
            {
                const data_content_fsm_transition & fsm_transition = * fsm_transition_i ;
                _collect_fsm_inputs_from_condition_groups ( fsm_machine_name , fsm_transition . condition_groups ) ;
            }
        }
    }

    _fsm_determine_inputs_change_code = _consts :: fsm_determine_inputs_change_begin ( _current_fsm_system_name ) ;

    for ( typename _collected_fsm_inputs_type :: const_iterator collected_input_i = _collected_fsm_inputs . begin ( )
        ; collected_input_i != _collected_fsm_inputs . end ( )
        ; ++ collected_input_i
        )
    {
        bool first_input = collected_input_i == _collected_fsm_inputs . begin ( ) ;
        if ( first_input )
            _fsm_determine_inputs_change_code += _consts :: fsm_determine_inputs_change_entry_first ( * collected_input_i ) ;
        else
            _fsm_determine_inputs_change_code += _consts :: fsm_determine_inputs_change_entry_next ( * collected_input_i ) ;
    }

    _fsm_determine_inputs_change_code += _consts :: fsm_determine_inputs_change_end ( ) ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_recalc_inputs ( )
{
    _collected_fsm_recalc_inputs_entries . clear ( ) ;

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        std :: string fsm_machine_name = fsm_machine_i -> first ;
        const data_content_fsm_machine & fsm_machine = fsm_machine_i -> second ;
        for ( typename data_content_fsm_state_container :: const_iterator fsm_state_i = fsm_machine . states . begin ( )
            ; fsm_state_i != fsm_machine . states . end ( )
            ; ++ fsm_state_i
            )
        {
            const data_content_fsm_state & fsm_state = fsm_state_i -> second ;
            for ( typename data_content_fsm_on_input_container :: const_iterator fsm_on_input_i = fsm_state . on_input . begin ( )
                ; fsm_on_input_i != fsm_state . on_input . end ( )
                ; ++ fsm_on_input_i
                )
            {
                const data_content_fsm_on_input & fsm_on_input = * fsm_on_input_i ;
                _collect_fsm_recalc_inputs_entries_from_condition_groups ( fsm_machine_name , fsm_on_input . condition_groups ) ;
            }
            for ( typename data_content_fsm_transition_container :: const_iterator fsm_transition_i = fsm_state . transitions . begin ( )
                ; fsm_transition_i != fsm_state . transitions . end ( )
                ; ++ fsm_transition_i
                )
            {
                const data_content_fsm_transition & fsm_transition = * fsm_transition_i ;
                _collect_fsm_recalc_inputs_entries_from_condition_groups ( fsm_machine_name , fsm_transition . condition_groups ) ;
            }
        }
    }

    _fsm_recalc_inputs_code = _consts :: fsm_recalc_inputs_begin ( _current_fsm_system_name ) ;

    for ( typename _collected_fsm_recalc_inputs_entries_type :: const_iterator entry_i = _collected_fsm_recalc_inputs_entries . begin ( )
        ; entry_i != _collected_fsm_recalc_inputs_entries . end ( )
        ; ++ entry_i
        )
    {
        _fsm_recalc_inputs_code += * entry_i ;
    }

    _fsm_recalc_inputs_code += _consts :: fsm_recalc_inputs_end ( ) ;
}

template < typename data_generator_types >
void shy_data_generator < data_generator_types > :: _generate_fsm_tick ( )
{
    _fsm_tick_code = _consts :: fsm_tick_begin ( _current_fsm_system_name ) ;   

    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = _current_fsm_system -> machines . begin ( )
        ; fsm_machine_i != _current_fsm_system -> machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        std :: string fsm_machine_name = fsm_machine_i -> first ;
        _fsm_tick_code += _consts :: fsm_tick_entry ( fsm_machine_name ) ;
    }

    _fsm_tick_code += _consts :: fsm_tick_end ( ) ;
}

