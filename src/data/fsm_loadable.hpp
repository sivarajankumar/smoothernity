template 
    < typename _logic_fsm
    >
class shy_data_fsm_loadable_types
{
public :
    typedef _logic_fsm logic_fsm ;
} ;

template < typename data_fsm_loadable_types >
class shy_data_fsm_loadable
{
    typedef typename data_fsm_loadable_types :: logic_fsm :: actions_type actions_type ;
    typedef typename data_fsm_loadable_types :: logic_fsm :: inputs_type inputs_type ;
    typedef typename data_fsm_loadable_types :: logic_fsm :: mediator_type mediator_type ;
    typedef typename data_fsm_loadable_types :: logic_fsm :: mediator_type :: engine_fsm engine_fsm ;
    typedef typename data_fsm_loadable_types :: logic_fsm :: mediator_type :: fsm_collection fsm_collection ;
    typedef typename data_fsm_loadable_types :: logic_fsm :: mediator_type :: fsm_collection :: data_binder data_binder ;
    typedef typename data_fsm_loadable_types :: logic_fsm :: mediator_type :: fsm_collection :: data_content data_content ;
    typedef typename data_fsm_loadable_types :: logic_fsm :: mediator_type :: platform :: platform_conditions platform_conditions ;
    typedef typename data_fsm_loadable_types :: logic_fsm :: mediator_type :: platform :: platform_math platform_math ;
    typedef typename data_fsm_loadable_types :: logic_fsm :: mediator_type :: platform :: platform_math :: num_whole num_whole ;
    typedef typename data_fsm_loadable_types :: logic_fsm :: mediator_type :: platform :: platform_pointer platform_pointer ;

    typedef typename data_content :: data_content_fsm_machine_container data_content_fsm_machine_container ;
    typedef typename data_content :: data_content_fsm_system data_content_fsm_system ;

    typedef typename fsm_collection :: template reflection < mediator_type > reflection ;
    typedef shy_data_fsm_loadable < data_fsm_loadable_types > data_fsm_loadable ;

    class _consts
    {
    public :
        static std :: string state_initial ( ) { return "initial" ; }
    } ;

public :
    shy_data_fsm_loadable ( ) ;

    void set_mediator ( typename platform_pointer :: template pointer < mediator_type > ) ;
    void set_actions ( typename platform_pointer :: template pointer < actions_type > ) ;
    void set_inputs ( typename platform_pointer :: template pointer < inputs_type > ) ;

    void init ( ) ;
    void is_fsm_running ( num_whole & ) ;
    void run_fsm_begin ( ) ;
    void run_fsm_end ( ) ;
    void reset_autogenerated_input_events ( ) ;
    void recalc_current_autogenerated_inputs ( ) ;
    void determine_autogenerated_inputs_change ( num_whole & ) ;
    void update_fixed_autogenerated_inputs ( ) ;
    void tick_all_fsms ( ) ;

    void bind_fsm_system ( std :: string ) ;
    void bind_fsm_input ( std :: string , num_whole & ) ;
    void bind_fsm_action ( std :: string , void ( actions_type :: * ) ( ) ) ;
private :
    num_whole _fsm_running ;
    typename platform_pointer :: template pointer < fsm_collection > _fsm_collection ;
    typename platform_pointer :: template pointer < actions_type > _actions ;
    typename platform_pointer :: template pointer < inputs_type > _inputs ;
    typename platform_pointer :: template pointer < data_binder > _binder ;
    typename platform_pointer :: template pointer < data_content > _content ;

    std :: string _fsm_system_name ;
    std :: map < std :: string , num_whole * > _inputs_binding ;
    std :: map < std :: string , void ( actions_type :: * ) ( ) > _actions_binding ;
    std :: map < std :: string , std :: string > _machines ;
} ;

template < typename data_fsm_loadable_types >
shy_data_fsm_loadable < data_fsm_loadable_types > :: shy_data_fsm_loadable ( )
{
    platform_math :: make_num_whole ( _fsm_running , false ) ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: set_mediator ( typename platform_pointer :: template pointer < mediator_type > mediator )
{
    mediator . get ( ) . fsm_collection_obj ( _fsm_collection ) ;

    _fsm_collection . get ( ) . binder ( _binder ) ;
    _fsm_collection . get ( ) . content ( _content ) ;

    typename platform_pointer :: template pointer < data_fsm_loadable > this_ptr ;
    platform_pointer :: bind ( this_ptr , * this ) ;

    reflection :: bind ( _actions , _inputs , this_ptr ) ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: set_actions ( typename platform_pointer :: template pointer < actions_type > actions )
{
    _actions = actions ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: set_inputs ( typename platform_pointer :: template pointer < inputs_type > inputs )
{
    _inputs = inputs ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: init ( )
{
    data_content_fsm_system & fsm_system = _content . get ( ) . fsm_systems [ _fsm_system_name ] ;
    for ( typename data_content_fsm_machine_container :: const_iterator fsm_machine_i = fsm_system . machines . begin ( )
        ; fsm_machine_i != fsm_system . machines . end ( )
        ; ++ fsm_machine_i
        )
    {
        std :: string fsm_machine_name = fsm_machine_i -> first ;
        _machines [ fsm_machine_name ] = _consts :: state_initial ( ) ;
    }
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: bind_fsm_system ( std :: string name )
{
    _fsm_system_name = name ;
    _binder . get ( ) . bind_fsm_system ( name ) ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: bind_fsm_input ( std :: string name , num_whole & input )
{
    _inputs_binding [ name ] = & input ;
    _binder . get ( ) . bind_fsm_input ( name ) ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: bind_fsm_action ( std :: string name , void ( actions_type :: * action ) ( ) )
{
    _actions_binding [ name ] = action ;
    _binder . get ( ) . bind_fsm_action ( name ) ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: is_fsm_running ( num_whole & result )
{
    result = _fsm_running ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: run_fsm_begin ( )
{
    platform_math :: make_num_whole ( _fsm_running , true ) ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: run_fsm_end ( )
{
    platform_math :: make_num_whole ( _fsm_running , false ) ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: reset_autogenerated_input_events ( )
{
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: recalc_current_autogenerated_inputs ( )
{
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: determine_autogenerated_inputs_change ( num_whole & result )
{
    platform_math :: make_num_whole ( result , false ) ;
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: update_fixed_autogenerated_inputs ( )
{
}

template < typename data_fsm_loadable_types >
void shy_data_fsm_loadable < data_fsm_loadable_types > :: tick_all_fsms ( )
{
}

